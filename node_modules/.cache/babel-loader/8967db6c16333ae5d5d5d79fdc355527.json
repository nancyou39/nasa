{"ast":null,"code":"function _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nimport * as React from 'react';\nimport DownOutlined from '@ant-design/icons/DownOutlined';\nimport Checkbox from '../../checkbox';\nimport Dropdown from '../../dropdown';\nimport Menu from '../../menu';\nimport Radio from '../../radio';\nimport warning from '../../_util/warning';\nvar EMPTY_LIST = []; // TODO: warning if use ajax!!!\n\nexport var SELECTION_ALL = 'SELECT_ALL';\nexport var SELECTION_INVERT = 'SELECT_INVERT';\n\nfunction getFixedType(column) {\n  return column && column.fixed;\n}\n\nfunction flattenData(data, childrenColumnName) {\n  var list = [];\n  (data || []).forEach(function (record) {\n    list.push(record);\n\n    if (childrenColumnName in record) {\n      list = [].concat(_toConsumableArray(list), _toConsumableArray(flattenData(record[childrenColumnName], childrenColumnName)));\n    }\n  });\n  return list;\n}\n\nexport default function useSelection(rowSelection, config) {\n  var _ref = rowSelection || {},\n      selectedRowKeys = _ref.selectedRowKeys,\n      getCheckboxProps = _ref.getCheckboxProps,\n      onSelectionChange = _ref.onChange,\n      onSelect = _ref.onSelect,\n      onSelectAll = _ref.onSelectAll,\n      onSelectInvert = _ref.onSelectInvert,\n      onSelectMultiple = _ref.onSelectMultiple,\n      _ref$columnWidth = _ref.columnWidth,\n      selectionColWidth = _ref$columnWidth === void 0 ? 60 : _ref$columnWidth,\n      selectionType = _ref.type,\n      selections = _ref.selections,\n      fixed = _ref.fixed;\n\n  var prefixCls = config.prefixCls,\n      data = config.data,\n      pageData = config.pageData,\n      getRecordByKey = config.getRecordByKey,\n      getRowKey = config.getRowKey,\n      expandType = config.expandType,\n      childrenColumnName = config.childrenColumnName,\n      tableLocale = config.locale,\n      expandIconColumnIndex = config.expandIconColumnIndex;\n\n  var _React$useState = React.useState(),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      innerSelectedKeys = _React$useState2[0],\n      setInnerSelectedKeys = _React$useState2[1];\n\n  var mergedSelectedKeys = selectedRowKeys || innerSelectedKeys || EMPTY_LIST;\n  var mergedSelectedKeySet = React.useMemo(function () {\n    var keys = selectionType === 'radio' ? mergedSelectedKeys.slice(0, 1) : mergedSelectedKeys;\n    return new Set(keys);\n  }, [mergedSelectedKeys, selectionType]); // Save last selected key to enable range selection\n\n  var _React$useState3 = React.useState(null),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      lastSelectedKey = _React$useState4[0],\n      setLastSelectedKey = _React$useState4[1]; // Reset if rowSelection reset\n\n\n  React.useEffect(function () {\n    if (!rowSelection) {\n      setInnerSelectedKeys([]);\n    }\n  }, [!!rowSelection]);\n  var setSelectedKeys = React.useCallback(function (keys) {\n    setInnerSelectedKeys(keys);\n    var records = keys.map(function (key) {\n      return getRecordByKey(key);\n    });\n\n    if (onSelectionChange) {\n      onSelectionChange(keys, records);\n    }\n  }, [setInnerSelectedKeys, getRecordByKey, onSelectionChange]); // Trigger single `onSelect` event\n\n  var triggerSingleSelection = React.useCallback(function (key, selected, keys, event) {\n    if (onSelect) {\n      var rows = keys.map(function (k) {\n        return getRecordByKey(k);\n      });\n      onSelect(getRecordByKey(key), selected, rows, event);\n    }\n\n    setSelectedKeys(keys);\n  }, [onSelect, getRecordByKey, setSelectedKeys]);\n  var mergedSelections = React.useMemo(function () {\n    if (!selections) {\n      return null;\n    }\n\n    var selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT] : selections;\n    return selectionList.map(function (selection) {\n      if (selection === SELECTION_ALL) {\n        return {\n          key: 'all',\n          text: tableLocale.selectionAll,\n          onSelect: function onSelect() {\n            setSelectedKeys(data.map(function (record, index) {\n              return getRowKey(record, index);\n            }));\n          }\n        };\n      }\n\n      if (selection === SELECTION_INVERT) {\n        return {\n          key: 'invert',\n          text: tableLocale.selectInvert,\n          onSelect: function onSelect() {\n            var keySet = new Set(mergedSelectedKeySet);\n            pageData.forEach(function (record, index) {\n              var key = getRowKey(record, index);\n\n              if (keySet.has(key)) {\n                keySet[\"delete\"](key);\n              } else {\n                keySet.add(key);\n              }\n            });\n            var keys = Array.from(keySet);\n            setSelectedKeys(keys);\n\n            if (onSelectInvert) {\n              warning(false, 'Table', '`onSelectInvert` will be removed in future. Please use `onChange` instead.');\n              onSelectInvert(keys);\n            }\n          }\n        };\n      }\n\n      return selection;\n    });\n  }, [selections, mergedSelectedKeySet, pageData, getRowKey]);\n  var transformColumns = React.useCallback(function (columns) {\n    if (!rowSelection) {\n      return columns;\n    } // Get flatten data\n\n\n    var flattedData = flattenData(pageData, childrenColumnName); // Support selection\n\n    var keySet = new Set(mergedSelectedKeySet); // Get all checkbox props\n\n    var checkboxPropsMap = new Map();\n    flattedData.forEach(function (record, index) {\n      var key = getRowKey(record, index);\n      var checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};\n      checkboxPropsMap.set(key, checkboxProps);\n\n      if (process.env.NODE_ENV !== 'production' && ('checked' in checkboxProps || 'defaultChecked' in checkboxProps)) {\n        warning(false, 'Table', 'Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.');\n      }\n    }); // Record key only need check with enabled\n\n    var recordKeys = flattedData.map(getRowKey).filter(function (key) {\n      return !checkboxPropsMap.get(key).disabled;\n    });\n    var checkedCurrentAll = recordKeys.every(function (key) {\n      return keySet.has(key);\n    });\n    var checkedCurrentSome = recordKeys.some(function (key) {\n      return keySet.has(key);\n    });\n\n    var onSelectAllChange = function onSelectAllChange() {\n      var changeKeys = [];\n\n      if (checkedCurrentAll) {\n        recordKeys.forEach(function (key) {\n          keySet[\"delete\"](key);\n          changeKeys.push(key);\n        });\n      } else {\n        recordKeys.forEach(function (key) {\n          keySet.add(key);\n          changeKeys.push(key);\n        });\n      }\n\n      var keys = Array.from(keySet);\n      setSelectedKeys(keys);\n\n      if (onSelectAll) {\n        onSelectAll(!checkedCurrentAll, keys.map(function (k) {\n          return getRecordByKey(k);\n        }), changeKeys.map(function (k) {\n          return getRecordByKey(k);\n        }));\n      }\n    }; // ===================== Render =====================\n    // Title Cell\n\n\n    var title;\n\n    if (selectionType !== 'radio') {\n      var customizeSelections;\n\n      if (mergedSelections) {\n        var menu = React.createElement(Menu, null, mergedSelections.map(function (selection, index) {\n          var key = selection.key,\n              text = selection.text,\n              onSelectionClick = selection.onSelect;\n          return React.createElement(Menu.Item, {\n            key: key || index,\n            onClick: function onClick() {\n              if (onSelectionClick) {\n                onSelectionClick(recordKeys);\n              }\n            }\n          }, text);\n        }));\n        customizeSelections = React.createElement(\"div\", {\n          className: \"\".concat(prefixCls, \"-selection-extra\")\n        }, React.createElement(Dropdown, {\n          overlay: menu\n        }, React.createElement(\"span\", null, React.createElement(DownOutlined, null))));\n      }\n\n      var allDisabled = flattedData.every(function (record, index) {\n        var key = getRowKey(record, index);\n        var checkboxProps = checkboxPropsMap.get(key) || {};\n        return checkboxProps.disabled;\n      });\n      title = React.createElement(\"div\", {\n        className: \"\".concat(prefixCls, \"-selection\")\n      }, React.createElement(Checkbox, {\n        checked: !allDisabled && !!flattedData.length && checkedCurrentAll,\n        indeterminate: !checkedCurrentAll && checkedCurrentSome,\n        onChange: onSelectAllChange,\n        disabled: flattedData.length === 0 || allDisabled\n      }), customizeSelections);\n    } // Body Cell\n\n\n    var renderCell;\n\n    if (selectionType === 'radio') {\n      renderCell = function renderCell(_, record, index) {\n        var key = getRowKey(record, index);\n        return React.createElement(Radio, _extends({}, checkboxPropsMap.get(key), {\n          checked: keySet.has(key),\n          onChange: function onChange(event) {\n            if (!keySet.has(key)) {\n              triggerSingleSelection(key, true, [key], event.nativeEvent);\n            }\n          }\n        }));\n      };\n    } else {\n      renderCell = function renderCell(_, record, index) {\n        var key = getRowKey(record, index);\n        var hasKey = keySet.has(key); // Record checked\n\n        return React.createElement(Checkbox, _extends({}, checkboxPropsMap.get(key), {\n          checked: hasKey,\n          onChange: function onChange(_ref2) {\n            var nativeEvent = _ref2.nativeEvent;\n            var shiftKey = nativeEvent.shiftKey;\n            var startIndex = -1;\n            var endIndex = -1; // Get range of this\n\n            if (shiftKey) {\n              var pointKeys = new Set([lastSelectedKey, key]);\n              recordKeys.some(function (recordKey, recordIndex) {\n                if (pointKeys.has(recordKey)) {\n                  if (startIndex === -1) {\n                    startIndex = recordIndex;\n                  } else {\n                    endIndex = recordIndex;\n                    return true;\n                  }\n                }\n\n                return false;\n              });\n            }\n\n            if (endIndex !== -1 && startIndex !== endIndex) {\n              // Batch update selections\n              var rangeKeys = recordKeys.slice(startIndex, endIndex + 1);\n              var changedKeys = [];\n\n              if (hasKey) {\n                rangeKeys.forEach(function (recordKey) {\n                  if (keySet.has(recordKey)) {\n                    changedKeys.push(recordKey);\n                    keySet[\"delete\"](recordKey);\n                  }\n                });\n              } else {\n                rangeKeys.forEach(function (recordKey) {\n                  if (!keySet.has(recordKey)) {\n                    changedKeys.push(recordKey);\n                    keySet.add(recordKey);\n                  }\n                });\n              }\n\n              var keys = Array.from(keySet);\n              setSelectedKeys(keys);\n\n              if (onSelectMultiple) {\n                onSelectMultiple(!hasKey, keys.map(function (recordKey) {\n                  return getRecordByKey(recordKey);\n                }), changedKeys.map(function (recordKey) {\n                  return getRecordByKey(recordKey);\n                }));\n              }\n            } else {\n              // Single record selected\n              if (hasKey) {\n                keySet[\"delete\"](key);\n              } else {\n                keySet.add(key);\n              }\n\n              triggerSingleSelection(key, !hasKey, Array.from(keySet), nativeEvent);\n            }\n\n            setLastSelectedKey(key);\n          }\n        }));\n      };\n    } // Columns\n\n\n    var selectionColumn = {\n      width: selectionColWidth,\n      className: \"\".concat(prefixCls, \"-selection-column\"),\n      title: rowSelection.columnTitle || title,\n      render: renderCell\n    };\n\n    if (expandType === 'row' && columns.length && !expandIconColumnIndex) {\n      var _columns = _toArray(columns),\n          expandColumn = _columns[0],\n          restColumns = _columns.slice(1);\n\n      return [expandColumn, _extends(_extends({}, selectionColumn), {\n        fixed: fixed || getFixedType(restColumns[0])\n      })].concat(_toConsumableArray(restColumns));\n    }\n\n    return [_extends(_extends({}, selectionColumn), {\n      fixed: fixed || getFixedType(columns[0])\n    })].concat(_toConsumableArray(columns));\n  }, [getRowKey, pageData, rowSelection, innerSelectedKeys, mergedSelectedKeys, selectionColWidth, mergedSelections, expandType, lastSelectedKey, onSelectMultiple, triggerSingleSelection]);\n  return [transformColumns, mergedSelectedKeySet];\n}","map":{"version":3,"sources":["table/hooks/useSelection.jsx"],"names":["EMPTY_LIST","SELECTION_ALL","SELECTION_INVERT","column","list","data","childrenColumnName","flattenData","record","selectedRowKeys","getCheckboxProps","onSelectionChange","onSelect","onSelectAll","onSelectInvert","onSelectMultiple","selectionColWidth","selectionType","selections","fixed","rowSelection","prefixCls","pageData","getRecordByKey","getRowKey","expandType","tableLocale","expandIconColumnIndex","config","innerSelectedKeys","setInnerSelectedKeys","React","mergedSelectedKeys","mergedSelectedKeySet","keys","lastSelectedKey","setLastSelectedKey","setSelectedKeys","records","triggerSingleSelection","rows","mergedSelections","selectionList","selection","key","text","keySet","Array","warning","transformColumns","flattedData","checkboxPropsMap","checkboxProps","process","recordKeys","checkedCurrentAll","checkedCurrentSome","onSelectAllChange","changeKeys","menu","onSelectionClick","customizeSelections","allDisabled","title","renderCell","event","hasKey","nativeEvent","shiftKey","startIndex","endIndex","pointKeys","rangeKeys","changedKeys","selectionColumn","width","className","render","columns","expandColumn","restColumns","getFixedType"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport DownOutlined from '@ant-design/icons/DownOutlined';\nimport Checkbox from '../../checkbox';\nimport Dropdown from '../../dropdown';\nimport Menu from '../../menu';\nimport Radio from '../../radio';\nimport warning from '../../_util/warning';\nconst EMPTY_LIST = [];\n// TODO: warning if use ajax!!!\nexport const SELECTION_ALL = 'SELECT_ALL';\nexport const SELECTION_INVERT = 'SELECT_INVERT';\nfunction getFixedType(column) {\n    return column && column.fixed;\n}\nfunction flattenData(data, childrenColumnName) {\n    let list = [];\n    (data || []).forEach(record => {\n        list.push(record);\n        if (childrenColumnName in record) {\n            list = [\n                ...list,\n                ...flattenData(record[childrenColumnName], childrenColumnName),\n            ];\n        }\n    });\n    return list;\n}\nexport default function useSelection(rowSelection, config) {\n    const { selectedRowKeys, getCheckboxProps, onChange: onSelectionChange, onSelect, onSelectAll, onSelectInvert, onSelectMultiple, columnWidth: selectionColWidth = 60, type: selectionType, selections, fixed, } = rowSelection || {};\n    const { prefixCls, data, pageData, getRecordByKey, getRowKey, expandType, childrenColumnName, locale: tableLocale, expandIconColumnIndex, } = config;\n    const [innerSelectedKeys, setInnerSelectedKeys] = React.useState();\n    const mergedSelectedKeys = selectedRowKeys || innerSelectedKeys || EMPTY_LIST;\n    const mergedSelectedKeySet = React.useMemo(() => {\n        const keys = selectionType === 'radio' ? mergedSelectedKeys.slice(0, 1) : mergedSelectedKeys;\n        return new Set(keys);\n    }, [mergedSelectedKeys, selectionType]);\n    // Save last selected key to enable range selection\n    const [lastSelectedKey, setLastSelectedKey] = React.useState(null);\n    // Reset if rowSelection reset\n    React.useEffect(() => {\n        if (!rowSelection) {\n            setInnerSelectedKeys([]);\n        }\n    }, [!!rowSelection]);\n    const setSelectedKeys = React.useCallback((keys) => {\n        setInnerSelectedKeys(keys);\n        const records = keys.map(key => getRecordByKey(key));\n        if (onSelectionChange) {\n            onSelectionChange(keys, records);\n        }\n    }, [setInnerSelectedKeys, getRecordByKey, onSelectionChange]);\n    // Trigger single `onSelect` event\n    const triggerSingleSelection = React.useCallback((key, selected, keys, event) => {\n        if (onSelect) {\n            const rows = keys.map(k => getRecordByKey(k));\n            onSelect(getRecordByKey(key), selected, rows, event);\n        }\n        setSelectedKeys(keys);\n    }, [onSelect, getRecordByKey, setSelectedKeys]);\n    const mergedSelections = React.useMemo(() => {\n        if (!selections) {\n            return null;\n        }\n        const selectionList = selections === true ? [SELECTION_ALL, SELECTION_INVERT] : selections;\n        return selectionList.map((selection) => {\n            if (selection === SELECTION_ALL) {\n                return {\n                    key: 'all',\n                    text: tableLocale.selectionAll,\n                    onSelect() {\n                        setSelectedKeys(data.map((record, index) => getRowKey(record, index)));\n                    },\n                };\n            }\n            if (selection === SELECTION_INVERT) {\n                return {\n                    key: 'invert',\n                    text: tableLocale.selectInvert,\n                    onSelect() {\n                        const keySet = new Set(mergedSelectedKeySet);\n                        pageData.forEach((record, index) => {\n                            const key = getRowKey(record, index);\n                            if (keySet.has(key)) {\n                                keySet.delete(key);\n                            }\n                            else {\n                                keySet.add(key);\n                            }\n                        });\n                        const keys = Array.from(keySet);\n                        setSelectedKeys(keys);\n                        if (onSelectInvert) {\n                            warning(false, 'Table', '`onSelectInvert` will be removed in future. Please use `onChange` instead.');\n                            onSelectInvert(keys);\n                        }\n                    },\n                };\n            }\n            return selection;\n        });\n    }, [selections, mergedSelectedKeySet, pageData, getRowKey]);\n    const transformColumns = React.useCallback((columns) => {\n        if (!rowSelection) {\n            return columns;\n        }\n        // Get flatten data\n        const flattedData = flattenData(pageData, childrenColumnName);\n        // Support selection\n        const keySet = new Set(mergedSelectedKeySet);\n        // Get all checkbox props\n        const checkboxPropsMap = new Map();\n        flattedData.forEach((record, index) => {\n            const key = getRowKey(record, index);\n            const checkboxProps = (getCheckboxProps ? getCheckboxProps(record) : null) || {};\n            checkboxPropsMap.set(key, checkboxProps);\n            if (process.env.NODE_ENV !== 'production' &&\n                ('checked' in checkboxProps || 'defaultChecked' in checkboxProps)) {\n                warning(false, 'Table', 'Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.');\n            }\n        });\n        // Record key only need check with enabled\n        const recordKeys = flattedData\n            .map(getRowKey)\n            .filter(key => !checkboxPropsMap.get(key).disabled);\n        const checkedCurrentAll = recordKeys.every(key => keySet.has(key));\n        const checkedCurrentSome = recordKeys.some(key => keySet.has(key));\n        const onSelectAllChange = () => {\n            const changeKeys = [];\n            if (checkedCurrentAll) {\n                recordKeys.forEach(key => {\n                    keySet.delete(key);\n                    changeKeys.push(key);\n                });\n            }\n            else {\n                recordKeys.forEach(key => {\n                    keySet.add(key);\n                    changeKeys.push(key);\n                });\n            }\n            const keys = Array.from(keySet);\n            setSelectedKeys(keys);\n            if (onSelectAll) {\n                onSelectAll(!checkedCurrentAll, keys.map(k => getRecordByKey(k)), changeKeys.map(k => getRecordByKey(k)));\n            }\n        };\n        // ===================== Render =====================\n        // Title Cell\n        let title;\n        if (selectionType !== 'radio') {\n            let customizeSelections;\n            if (mergedSelections) {\n                const menu = (<Menu>\n              {mergedSelections.map((selection, index) => {\n                    const { key, text, onSelect: onSelectionClick } = selection;\n                    return (<Menu.Item key={key || index} onClick={() => {\n                        if (onSelectionClick) {\n                            onSelectionClick(recordKeys);\n                        }\n                    }}>\n                    {text}\n                  </Menu.Item>);\n                })}\n            </Menu>);\n                customizeSelections = (<div className={`${prefixCls}-selection-extra`}>\n              <Dropdown overlay={menu}>\n                <span>\n                  <DownOutlined />\n                </span>\n              </Dropdown>\n            </div>);\n            }\n            const allDisabled = flattedData.every((record, index) => {\n                const key = getRowKey(record, index);\n                const checkboxProps = checkboxPropsMap.get(key) || {};\n                return checkboxProps.disabled;\n            });\n            title = (<div className={`${prefixCls}-selection`}>\n            <Checkbox checked={!allDisabled && !!flattedData.length && checkedCurrentAll} indeterminate={!checkedCurrentAll && checkedCurrentSome} onChange={onSelectAllChange} disabled={flattedData.length === 0 || allDisabled}/>\n            {customizeSelections}\n          </div>);\n        }\n        // Body Cell\n        let renderCell;\n        if (selectionType === 'radio') {\n            renderCell = (_, record, index) => {\n                const key = getRowKey(record, index);\n                return (<Radio {...checkboxPropsMap.get(key)} checked={keySet.has(key)} onChange={event => {\n                    if (!keySet.has(key)) {\n                        triggerSingleSelection(key, true, [key], event.nativeEvent);\n                    }\n                }}/>);\n            };\n        }\n        else {\n            renderCell = (_, record, index) => {\n                const key = getRowKey(record, index);\n                const hasKey = keySet.has(key);\n                // Record checked\n                return (<Checkbox {...checkboxPropsMap.get(key)} checked={hasKey} onChange={({ nativeEvent }) => {\n                    const { shiftKey } = nativeEvent;\n                    let startIndex = -1;\n                    let endIndex = -1;\n                    // Get range of this\n                    if (shiftKey) {\n                        const pointKeys = new Set([lastSelectedKey, key]);\n                        recordKeys.some((recordKey, recordIndex) => {\n                            if (pointKeys.has(recordKey)) {\n                                if (startIndex === -1) {\n                                    startIndex = recordIndex;\n                                }\n                                else {\n                                    endIndex = recordIndex;\n                                    return true;\n                                }\n                            }\n                            return false;\n                        });\n                    }\n                    if (endIndex !== -1 && startIndex !== endIndex) {\n                        // Batch update selections\n                        const rangeKeys = recordKeys.slice(startIndex, endIndex + 1);\n                        const changedKeys = [];\n                        if (hasKey) {\n                            rangeKeys.forEach(recordKey => {\n                                if (keySet.has(recordKey)) {\n                                    changedKeys.push(recordKey);\n                                    keySet.delete(recordKey);\n                                }\n                            });\n                        }\n                        else {\n                            rangeKeys.forEach(recordKey => {\n                                if (!keySet.has(recordKey)) {\n                                    changedKeys.push(recordKey);\n                                    keySet.add(recordKey);\n                                }\n                            });\n                        }\n                        const keys = Array.from(keySet);\n                        setSelectedKeys(keys);\n                        if (onSelectMultiple) {\n                            onSelectMultiple(!hasKey, keys.map(recordKey => getRecordByKey(recordKey)), changedKeys.map(recordKey => getRecordByKey(recordKey)));\n                        }\n                    }\n                    else {\n                        // Single record selected\n                        if (hasKey) {\n                            keySet.delete(key);\n                        }\n                        else {\n                            keySet.add(key);\n                        }\n                        triggerSingleSelection(key, !hasKey, Array.from(keySet), nativeEvent);\n                    }\n                    setLastSelectedKey(key);\n                }}/>);\n            };\n        }\n        // Columns\n        const selectionColumn = {\n            width: selectionColWidth,\n            className: `${prefixCls}-selection-column`,\n            title: rowSelection.columnTitle || title,\n            render: renderCell,\n        };\n        if (expandType === 'row' && columns.length && !expandIconColumnIndex) {\n            const [expandColumn, ...restColumns] = columns;\n            return [\n                expandColumn,\n                Object.assign(Object.assign({}, selectionColumn), { fixed: fixed || getFixedType(restColumns[0]) }),\n                ...restColumns,\n            ];\n        }\n        return [Object.assign(Object.assign({}, selectionColumn), { fixed: fixed || getFixedType(columns[0]) }), ...columns];\n    }, [\n        getRowKey,\n        pageData,\n        rowSelection,\n        innerSelectedKeys,\n        mergedSelectedKeys,\n        selectionColWidth,\n        mergedSelections,\n        expandType,\n        lastSelectedKey,\n        onSelectMultiple,\n        triggerSingleSelection,\n    ]);\n    return [transformColumns, mergedSelectedKeySet];\n}\n"]},"metadata":{},"sourceType":"module"}