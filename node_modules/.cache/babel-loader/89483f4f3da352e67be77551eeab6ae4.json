{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\n\nexport function flattenOptions(options) {\n  var flattenList = [];\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      if (isGroupOption || !('options' in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data\n        });\n        dig(data.options, true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var optionMap = new Map();\n  options.forEach(function (flattenItem) {\n    if (!flattenItem.group) {\n      var data = flattenItem.data; // Check if match\n\n      optionMap.set(data.value, data);\n    }\n  });\n  return values.map(function (val) {\n    return injectPropsWithOption(optionMap.get(val));\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref) {\n  var options = _ref.options,\n      prevValue = _ref.prevValue,\n      labelInValue = _ref.labelInValue,\n      optionLabelProp = _ref.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem;\n  var prevValues = toArray(prevValue);\n\n  if (labelInValue) {\n    prevValItem = prevValues.find(function (prevItem) {\n      if (_typeof(prevItem) === 'object' && 'value' in prevItem) {\n        return prevItem.value === value;\n      } // [Legacy] Support `key` as `value`\n\n\n      return prevItem.key === value;\n    });\n  }\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n  } // [Legacy] We need fill `key` as `value` to compatible old code usage\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText) && !option.disabled;\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref2) {\n  var optionFilterProp = _ref2.optionFilterProp,\n      filterOption = _ref2.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return options;\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread({}, item, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref3) {\n    var _ref4 = _toArray(_ref3),\n        token = _ref4[0],\n        restTokens = _ref4.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref5;\n\n      cloneOptions.push(labelInValue ? (_ref5 = {}, _defineProperty(_ref5, optionLabelProp, item.label), _defineProperty(_ref5, \"value\", val), _ref5) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}","map":{"version":3,"sources":["/Users/nancyou/Desktop/nasa/node_modules/rc-select/es/utils/valueUtil.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","Array","isArray","i","arr2","length","_toArray","_arrayWithHoles","_nonIterableRest","iter","Symbol","iterator","Object","prototype","toString","call","from","_typeof","obj","constructor","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","value","configurable","writable","warning","toArray","getKey","data","index","undefined","concat","flattenOptions","options","flattenList","dig","list","isGroupOption","groupOption","group","injectPropsWithOption","option","newOption","get","findValueOption","values","optionMap","Map","flattenItem","set","map","val","getLabeledValue","_ref","prevValue","labelInValue","optionLabelProp","item","result","prevValItem","prevValues","find","prevItem","label","trim","toRawString","content","join","getFilterFunction","optionFilterProp","searchValue","lowerSearchText","toLowerCase","includes","rawValue","disabled","filterOptions","_ref2","filterOption","filteredOptions","filterFunc","matchGroup","subOptions","subItem","getSeparatedContent","text","tokens","match","separate","str","_ref3","_ref4","token","restTokens","slice","split","reduce","prevList","unitStr","unit","isValueDisabled","fillOptionsWithMissingValue","sort","cloneOptions","optionValues","Set","opt","subOpt","add","has","_ref5"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport warning from \"rc-util/es/warning\";\nimport { toArray } from './commonUtil';\n\nfunction getKey(data, index) {\n  var key = data.key;\n  var value;\n\n  if ('value' in data) {\n    value = data.value;\n  }\n\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  return \"rc-index-key-\".concat(index);\n}\n/**\n * Flat options into flatten list.\n * We use `optionOnly` here is aim to avoid user use nested option group.\n * Here is simply set `key` to the index if not provided.\n */\n\n\nexport function flattenOptions(options) {\n  var flattenList = [];\n\n  function dig(list, isGroupOption) {\n    list.forEach(function (data) {\n      if (isGroupOption || !('options' in data)) {\n        // Option\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          groupOption: isGroupOption,\n          data: data\n        });\n      } else {\n        // Option Group\n        flattenList.push({\n          key: getKey(data, flattenList.length),\n          group: true,\n          data: data\n        });\n        dig(data.options, true);\n      }\n    });\n  }\n\n  dig(options, false);\n  return flattenList;\n}\n/**\n * Inject `props` into `option` for legacy usage\n */\n\nfunction injectPropsWithOption(option) {\n  var newOption = _objectSpread({}, option);\n\n  if (!('props' in newOption)) {\n    Object.defineProperty(newOption, 'props', {\n      get: function get() {\n        warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');\n        return newOption;\n      }\n    });\n  }\n\n  return newOption;\n}\n\nexport function findValueOption(values, options) {\n  var optionMap = new Map();\n  options.forEach(function (flattenItem) {\n    if (!flattenItem.group) {\n      var data = flattenItem.data; // Check if match\n\n      optionMap.set(data.value, data);\n    }\n  });\n  return values.map(function (val) {\n    return injectPropsWithOption(optionMap.get(val));\n  });\n}\nexport var getLabeledValue = function getLabeledValue(value, _ref) {\n  var options = _ref.options,\n      prevValue = _ref.prevValue,\n      labelInValue = _ref.labelInValue,\n      optionLabelProp = _ref.optionLabelProp;\n  var item = findValueOption([value], options)[0];\n  var result = {\n    value: value\n  };\n  var prevValItem;\n  var prevValues = toArray(prevValue);\n\n  if (labelInValue) {\n    prevValItem = prevValues.find(function (prevItem) {\n      if (_typeof(prevItem) === 'object' && 'value' in prevItem) {\n        return prevItem.value === value;\n      } // [Legacy] Support `key` as `value`\n\n\n      return prevItem.key === value;\n    });\n  }\n\n  if (prevValItem && _typeof(prevValItem) === 'object' && 'label' in prevValItem) {\n    result.label = prevValItem.label;\n\n    if (item && typeof prevValItem.label === 'string' && typeof item[optionLabelProp] === 'string' && prevValItem.label.trim() !== item[optionLabelProp].trim()) {\n      warning(false, '`label` of `value` is not same as `label` in Select options.');\n    }\n  } else if (item && optionLabelProp in item) {\n    result.label = item[optionLabelProp];\n  } else {\n    result.label = value;\n  } // [Legacy] We need fill `key` as `value` to compatible old code usage\n\n\n  result.key = result.value;\n  return result;\n};\n\nfunction toRawString(content) {\n  return toArray(content).join('');\n}\n/** Filter single option if match the search text */\n\n\nfunction getFilterFunction(optionFilterProp) {\n  return function (searchValue, option) {\n    var lowerSearchText = searchValue.toLowerCase(); // Group label search\n\n    if ('options' in option) {\n      return toRawString(option.label).toLowerCase().includes(lowerSearchText);\n    } // Option value search\n\n\n    var rawValue = option[optionFilterProp];\n    var value = toRawString(rawValue).toLowerCase();\n    return value.includes(lowerSearchText) && !option.disabled;\n  };\n}\n/** Filter options and return a new options by the search text */\n\n\nexport function filterOptions(searchValue, options, _ref2) {\n  var optionFilterProp = _ref2.optionFilterProp,\n      filterOption = _ref2.filterOption;\n  var filteredOptions = [];\n  var filterFunc;\n\n  if (filterOption === false) {\n    return options;\n  }\n\n  if (typeof filterOption === 'function') {\n    filterFunc = filterOption;\n  } else {\n    filterFunc = getFilterFunction(optionFilterProp);\n  }\n\n  options.forEach(function (item) {\n    // Group should check child options\n    if ('options' in item) {\n      // Check group first\n      var matchGroup = filterFunc(searchValue, item);\n\n      if (matchGroup) {\n        filteredOptions.push(item);\n      } else {\n        // Check option\n        var subOptions = item.options.filter(function (subItem) {\n          return filterFunc(searchValue, subItem);\n        });\n\n        if (subOptions.length) {\n          filteredOptions.push(_objectSpread({}, item, {\n            options: subOptions\n          }));\n        }\n      }\n\n      return;\n    }\n\n    if (filterFunc(searchValue, injectPropsWithOption(item))) {\n      filteredOptions.push(item);\n    }\n  });\n  return filteredOptions;\n}\nexport function getSeparatedContent(text, tokens) {\n  if (!tokens || !tokens.length) {\n    return null;\n  }\n\n  var match = false;\n\n  function separate(str, _ref3) {\n    var _ref4 = _toArray(_ref3),\n        token = _ref4[0],\n        restTokens = _ref4.slice(1);\n\n    if (!token) {\n      return [str];\n    }\n\n    var list = str.split(token);\n    match = match || list.length > 1;\n    return list.reduce(function (prevList, unitStr) {\n      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));\n    }, []).filter(function (unit) {\n      return unit;\n    });\n  }\n\n  var list = separate(text, tokens);\n  return match ? list : null;\n}\nexport function isValueDisabled(value, options) {\n  var option = findValueOption([value], options)[0];\n  return option.disabled;\n}\n/**\n * `tags` mode should fill un-list item into the option list\n */\n\nexport function fillOptionsWithMissingValue(options, value, optionLabelProp, labelInValue) {\n  var values = toArray(value).slice().sort();\n\n  var cloneOptions = _toConsumableArray(options); // Convert options value to set\n\n\n  var optionValues = new Set();\n  options.forEach(function (opt) {\n    if (opt.options) {\n      opt.options.forEach(function (subOpt) {\n        optionValues.add(subOpt.value);\n      });\n    } else {\n      optionValues.add(opt.value);\n    }\n  }); // Fill missing value\n\n  values.forEach(function (item) {\n    var val = labelInValue ? item.value : item;\n\n    if (!optionValues.has(val)) {\n      var _ref5;\n\n      cloneOptions.push(labelInValue ? (_ref5 = {}, _defineProperty(_ref5, optionLabelProp, item.label), _defineProperty(_ref5, \"value\", val), _ref5) : {\n        value: val\n      });\n    }\n  });\n  return cloneOptions;\n}"]},"metadata":{},"sourceType":"module"}