{"ast":null,"code":"import { createRule } from 'jss';\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\n\nfunction functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      } // $FlowFixMe\n\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var prop in fnValues) {\n          styleRule.prop(prop, fnValues[prop](data), options);\n        }\n      }\n    }\n  };\n}\n\nexport default functionPlugin;","map":{"version":3,"sources":["/Users/nancyou/Desktop/nasa/node_modules/jss-plugin-rule-value-function/dist/jss-plugin-rule-value-function.esm.js"],"names":["createRule","now","Date","fnValuesNs","fnRuleNs","functionPlugin","onCreateRule","name","decl","options","rule","onProcessStyle","style","fnValues","prop","value","onUpdate","data","sheet","styleRule","fnRule"],"mappings":"AAAA,SAASA,UAAT,QAA2B,KAA3B;AAEA,IAAIC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAV;AACA,IAAIE,UAAU,GAAG,aAAaF,GAA9B;AACA,IAAIG,QAAQ,GAAG,YAAY,EAAEH,GAA7B;;AACA,SAASI,cAAT,GAA0B;AACxB,SAAO;AACLC,IAAAA,YAAY,EAAE,SAASA,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,OAAlC,EAA2C;AACvD,UAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC,OAAO,IAAP;AAChC,UAAIE,IAAI,GAAGV,UAAU,CAACO,IAAD,EAAO,EAAP,EAAWE,OAAX,CAArB;AACAC,MAAAA,IAAI,CAACN,QAAD,CAAJ,GAAiBI,IAAjB;AACA,aAAOE,IAAP;AACD,KANI;AAOLC,IAAAA,cAAc,EAAE,SAASA,cAAT,CAAwBC,KAAxB,EAA+BF,IAA/B,EAAqC;AACnD;AACA;AACA;AACA;AACA,UAAIP,UAAU,IAAIO,IAAd,IAAsBN,QAAQ,IAAIM,IAAtC,EAA4C,OAAOE,KAAP;AAC5C,UAAIC,QAAQ,GAAG,EAAf;;AAEA,WAAK,IAAIC,IAAT,IAAiBF,KAAjB,EAAwB;AACtB,YAAIG,KAAK,GAAGH,KAAK,CAACE,IAAD,CAAjB;AACA,YAAI,OAAOC,KAAP,KAAiB,UAArB,EAAiC;AACjC,eAAOH,KAAK,CAACE,IAAD,CAAZ;AACAD,QAAAA,QAAQ,CAACC,IAAD,CAAR,GAAiBC,KAAjB;AACD,OAbkD,CAajD;;;AAGFL,MAAAA,IAAI,CAACP,UAAD,CAAJ,GAAmBU,QAAnB;AACA,aAAOD,KAAP;AACD,KAzBI;AA0BLI,IAAAA,QAAQ,EAAE,SAASA,QAAT,CAAkBC,IAAlB,EAAwBP,IAAxB,EAA8BQ,KAA9B,EAAqCT,OAArC,EAA8C;AACtD,UAAIU,SAAS,GAAGT,IAAhB;AACA,UAAIU,MAAM,GAAGD,SAAS,CAACf,QAAD,CAAtB,CAFsD,CAEpB;AAClC;;AAEA,UAAIgB,MAAJ,EAAY;AACV;AACA;AACAD,QAAAA,SAAS,CAACP,KAAV,GAAkBQ,MAAM,CAACH,IAAD,CAAN,IAAgB,EAAlC;AACD;;AAED,UAAIJ,QAAQ,GAAGM,SAAS,CAAChB,UAAD,CAAxB,CAXsD,CAWhB;;AAEtC,UAAIU,QAAJ,EAAc;AACZ,aAAK,IAAIC,IAAT,IAAiBD,QAAjB,EAA2B;AACzBM,UAAAA,SAAS,CAACL,IAAV,CAAeA,IAAf,EAAqBD,QAAQ,CAACC,IAAD,CAAR,CAAeG,IAAf,CAArB,EAA2CR,OAA3C;AACD;AACF;AACF;AA5CI,GAAP;AA8CD;;AAED,eAAeJ,cAAf","sourcesContent":["import { createRule } from 'jss';\n\nvar now = Date.now();\nvar fnValuesNs = \"fnValues\" + now;\nvar fnRuleNs = \"fnStyle\" + ++now;\nfunction functionPlugin() {\n  return {\n    onCreateRule: function onCreateRule(name, decl, options) {\n      if (typeof decl !== 'function') return null;\n      var rule = createRule(name, {}, options);\n      rule[fnRuleNs] = decl;\n      return rule;\n    },\n    onProcessStyle: function onProcessStyle(style, rule) {\n      // We need to extract function values from the declaration, so that we can keep core unaware of them.\n      // We need to do that only once.\n      // We don't need to extract functions on each style update, since this can happen only once.\n      // We don't support function values inside of function rules.\n      if (fnValuesNs in rule || fnRuleNs in rule) return style;\n      var fnValues = {};\n\n      for (var prop in style) {\n        var value = style[prop];\n        if (typeof value !== 'function') continue;\n        delete style[prop];\n        fnValues[prop] = value;\n      } // $FlowFixMe\n\n\n      rule[fnValuesNs] = fnValues;\n      return style;\n    },\n    onUpdate: function onUpdate(data, rule, sheet, options) {\n      var styleRule = rule;\n      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object\n      // will be returned from that function.\n\n      if (fnRule) {\n        // Empty object will remove all currently defined props\n        // in case function rule returns a falsy value.\n        styleRule.style = fnRule(data) || {};\n      }\n\n      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.\n\n      if (fnValues) {\n        for (var prop in fnValues) {\n          styleRule.prop(prop, fnValues[prop](data), options);\n        }\n      }\n    }\n  };\n}\n\nexport default functionPlugin;\n"]},"metadata":{},"sourceType":"module"}