{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nimport * as React from 'react';\nimport Alert from '.';\n\nvar ErrorBoundary =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(ErrorBoundary, _React$Component);\n\n  function ErrorBoundary() {\n    var _this;\n\n    _classCallCheck(this, ErrorBoundary);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ErrorBoundary).apply(this, arguments));\n    _this.state = {\n      error: undefined,\n      info: {\n        componentStack: ''\n      }\n    };\n    return _this;\n  }\n\n  _createClass(ErrorBoundary, [{\n    key: \"componentDidCatch\",\n    value: function componentDidCatch(error, info) {\n      this.setState({\n        error: error,\n        info: info\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          message = _this$props.message,\n          description = _this$props.description,\n          children = _this$props.children;\n      var _this$state = this.state,\n          error = _this$state.error,\n          info = _this$state.info;\n      var componentStack = info && info.componentStack ? info.componentStack : null;\n      var errorMessage = typeof message === 'undefined' ? (error || '').toString() : message;\n      var errorDescription = typeof description === 'undefined' ? componentStack : description;\n\n      if (error) {\n        return React.createElement(Alert, {\n          type: \"error\",\n          message: errorMessage,\n          description: React.createElement(\"pre\", null, errorDescription)\n        });\n      }\n\n      return children;\n    }\n  }]);\n\n  return ErrorBoundary;\n}(React.Component);\n\nexport { ErrorBoundary as default };","map":{"version":3,"sources":["alert/ErrorBoundary.jsx"],"names":["ErrorBoundary","React","Component","error","info","componentStack","message","description","children","errorMessage","errorDescription"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,OAAA,KAAA,MAAA,GAAA;;IACqBA,a;;;;;AACjB,WAAA,aAAA,GAAc;AAAA,QAAA,KAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA;;AACV,IAAA,KAAA,GAAA,0BAAA,CAAA,IAAA,EAAA,eAAA,CAAA,aAAA,CAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA;AACA,IAAA,KAAA,CAAA,KAAA,GAAa;AACTG,MAAAA,KAAK,EADI,SAAA;AAETC,MAAAA,IAAI,EAAE;AACFC,QAAAA,cAAc,EAAE;AADd;AAFG,KAAb;AAFU,WAAA,KAAA;AAQb;;;;sCACiBF,K,EAAOC,I,EAAM;AAC3B,WAAA,QAAA,CAAc;AAAED,QAAAA,KAAK,EAAP,KAAA;AAASC,QAAAA,IAAI,EAAJA;AAAT,OAAd;AACH;;;6BACQ;AAAA,UAAA,WAAA,GACsC,KADtC,KAAA;AAAA,UACGE,OADH,GAAA,WAAA,CAAA,OAAA;AAAA,UACYC,WADZ,GAAA,WAAA,CAAA,WAAA;AAAA,UACyBC,QADzB,GAAA,WAAA,CAAA,QAAA;AAAA,UAAA,WAAA,GAEmB,KAFnB,KAAA;AAAA,UAEGL,KAFH,GAAA,WAAA,CAAA,KAAA;AAAA,UAEUC,IAFV,GAAA,WAAA,CAAA,IAAA;AAGL,UAAMC,cAAc,GAAGD,IAAI,IAAIA,IAAI,CAAZA,cAAAA,GAA8BA,IAAI,CAAlCA,cAAAA,GAAvB,IAAA;AACA,UAAMK,YAAY,GAAG,OAAA,OAAA,KAAA,WAAA,GAAiC,CAACN,KAAK,IAAN,EAAA,EAAjC,QAAiC,EAAjC,GAArB,OAAA;AACA,UAAMO,gBAAgB,GAAG,OAAA,WAAA,KAAA,WAAA,GAAA,cAAA,GAAzB,WAAA;;AACA,UAAA,KAAA,EAAW;AACP,eAAQ,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA;AAAO,UAAA,IAAI,EAAX,OAAA;AAAoB,UAAA,OAAO,EAA3B,YAAA;AAA2C,UAAA,WAAW,EAAE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,IAAA,EAAA,gBAAA;AAAxD,SAAA,CAAR;AACH;;AACD,aAAA,QAAA;AACH;;;;EAvBsCT,KAAK,CAACC,S;;SAA5BF,a","sourcesContent":["import * as React from 'react';\nimport Alert from '.';\nexport default class ErrorBoundary extends React.Component {\n    constructor() {\n        super(...arguments);\n        this.state = {\n            error: undefined,\n            info: {\n                componentStack: '',\n            },\n        };\n    }\n    componentDidCatch(error, info) {\n        this.setState({ error, info });\n    }\n    render() {\n        const { message, description, children } = this.props;\n        const { error, info } = this.state;\n        const componentStack = info && info.componentStack ? info.componentStack : null;\n        const errorMessage = typeof message === 'undefined' ? (error || '').toString() : message;\n        const errorDescription = typeof description === 'undefined' ? componentStack : description;\n        if (error) {\n            return (<Alert type=\"error\" message={errorMessage} description={<pre>{errorDescription}</pre>}/>);\n        }\n        return children;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}