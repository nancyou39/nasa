{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === \"[object Arguments]\")) {\n    return;\n  }\n\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nimport * as React from 'react';\nimport useRCNotification from \"rc-notification/es/useNotification\";\nimport { ConfigConsumer } from '../../config-provider';\nexport default function createUseNotification(getNotificationInstance, getRCNoticeProps) {\n  var useNotification = function useNotification() {\n    // We can only get content by render\n    var getPrefixCls; // We create a proxy to handle delay created instance\n\n    var innerInstance = null;\n    var proxy = {\n      add: function add(noticeProps, holderCallback) {\n        innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n      }\n    };\n\n    var _useRCNotification = useRCNotification(proxy),\n        _useRCNotification2 = _slicedToArray(_useRCNotification, 2),\n        hookNotify = _useRCNotification2[0],\n        holder = _useRCNotification2[1];\n\n    function notify(args) {\n      var customizePrefixCls = args.prefixCls;\n      var mergedPrefixCls = getPrefixCls('notification', customizePrefixCls);\n      getNotificationInstance(_extends(_extends({}, args), {\n        prefixCls: mergedPrefixCls\n      }), function (_ref) {\n        var prefixCls = _ref.prefixCls,\n            instance = _ref.instance;\n        innerInstance = instance;\n        hookNotify(getRCNoticeProps(args, prefixCls));\n      });\n    } // Fill functions\n\n\n    var hookAPI = {\n      open: notify\n    };\n    ['success', 'info', 'warning', 'error'].forEach(function (type) {\n      hookAPI[type] = function (args) {\n        return hookAPI.open(_extends(_extends({}, args), {\n          type: type\n        }));\n      };\n    });\n    return [hookAPI, React.createElement(ConfigConsumer, {\n      key: \"holder\"\n    }, function (context) {\n      getPrefixCls = context.getPrefixCls;\n      return holder;\n    })];\n  };\n\n  return useNotification;\n}","map":{"version":3,"sources":["notification/hooks/useNotification.jsx"],"names":["useNotification","innerInstance","proxy","add","hookNotify","holder","useRCNotification","customizePrefixCls","args","mergedPrefixCls","getPrefixCls","getNotificationInstance","prefixCls","instance","getRCNoticeProps","hookAPI","open","notify","type","context"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,KAAA,MAAA,OAAA;AACA,OAAA,iBAAA,MAAA,oCAAA;AACA,SAAA,cAAA,QAAA,uBAAA;AACA,eAAe,SAAA,qBAAA,CAAA,uBAAA,EAAA,gBAAA,EAA0E;AACrF,MAAMA,eAAe,GAAG,SAAlBA,eAAkB,GAAM;AAC1B;AACA,QAF0B,YAE1B,CAF0B,CAG1B;;AACA,QAAIC,aAAa,GAAjB,IAAA;AACA,QAAMC,KAAK,GAAG;AACVC,MAAAA,GAAG,EAAE,SAAA,GAAA,CAAA,WAAA,EAAA,cAAA,EAAiC;AAClCF,QAAAA,aAAa,KAAbA,IAAAA,IAA0BA,aAAa,KAAK,KAA5CA,CAAAA,GAAqD,KAArDA,CAAAA,GAA8DA,aAAa,CAAbA,SAAAA,CAAAA,GAAAA,CAAAA,WAAAA,EAA9DA,cAA8DA,CAA9DA;AACH;AAHS,KAAd;;AAL0B,QAAA,kBAAA,GAUGK,iBAAiB,CAVpB,KAUoB,CAVpB;AAAA,QAAA,mBAAA,GAAA,cAAA,CAAA,kBAAA,EAAA,CAAA,CAAA;AAAA,QAUnBF,UAVmB,GAAA,mBAAA,CAAA,CAAA,CAAA;AAAA,QAUPC,MAVO,GAAA,mBAAA,CAAA,CAAA,CAAA;;AAW1B,aAAA,MAAA,CAAA,IAAA,EAAsB;AAAA,UACCE,kBADD,GACwBC,IADxB,CAAA,SAAA;AAElB,UAAMC,eAAe,GAAGC,YAAY,CAAA,cAAA,EAApC,kBAAoC,CAApC;AACAC,MAAAA,uBAAuB,CAAC,QAAA,CAAc,QAAA,CAAA,EAAA,EAAd,IAAc,CAAd,EAAuC;AAAEC,QAAAA,SAAS,EAAEH;AAAb,OAAvC,CAAD,EAAyE,UAAA,IAAA,EAA6B;AAAA,YAA1BG,SAA0B,GAAA,IAAA,CAA1BA,SAA0B;AAAA,YAAfC,QAAe,GAAA,IAAA,CAAfA,QAAe;AACzHZ,QAAAA,aAAa,GAAbA,QAAAA;AACAG,QAAAA,UAAU,CAACU,gBAAgB,CAAA,IAAA,EAA3BV,SAA2B,CAAjB,CAAVA;AAFJO,OAAuB,CAAvBA;AAdsB,KAAA,CAmB1B;;;AACA,QAAMI,OAAO,GAAG;AACZC,MAAAA,IAAI,EAAEC;AADM,KAAhB;AAGA,KAAA,SAAA,EAAA,MAAA,EAAA,SAAA,EAAA,OAAA,EAAA,OAAA,CAAgD,UAAA,IAAA,EAAQ;AACpDF,MAAAA,OAAO,CAAPA,IAAO,CAAPA,GAAgB,UAAA,IAAA,EAAA;AAAA,eAAU,OAAO,CAAP,IAAA,CAAa,QAAA,CAAc,QAAA,CAAA,EAAA,EAAd,IAAc,CAAd,EAAuC;AAAEG,UAAAA,IAAI,EAAJA;AAAF,SAAvC,CAAb,CAAV;AAAhBH,OAAAA;AADJ,KAAA;AAGA,WAAO,CAAA,OAAA,EAEH,KAAA,CAAA,aAAA,CAAA,cAAA,EAAA;AAAgB,MAAA,GAAG,EAAC;AAApB,KAAA,EACH,UAAA,OAAA,EAAa;AACHL,MAAAA,YADG,GACcS,OADd,CAAA,YACHT;AACH,aAAA,MAAA;AALR,KAEI,CAFG,CAAP;AA1BJ,GAAA;;AAoCA,SAAA,eAAA;AACH","sourcesContent":["import * as React from 'react';\nimport useRCNotification from 'rc-notification/lib/useNotification';\nimport { ConfigConsumer } from '../../config-provider';\nexport default function createUseNotification(getNotificationInstance, getRCNoticeProps) {\n    const useNotification = () => {\n        // We can only get content by render\n        let getPrefixCls;\n        // We create a proxy to handle delay created instance\n        let innerInstance = null;\n        const proxy = {\n            add: (noticeProps, holderCallback) => {\n                innerInstance === null || innerInstance === void 0 ? void 0 : innerInstance.component.add(noticeProps, holderCallback);\n            },\n        };\n        const [hookNotify, holder] = useRCNotification(proxy);\n        function notify(args) {\n            const { prefixCls: customizePrefixCls } = args;\n            const mergedPrefixCls = getPrefixCls('notification', customizePrefixCls);\n            getNotificationInstance(Object.assign(Object.assign({}, args), { prefixCls: mergedPrefixCls }), ({ prefixCls, instance }) => {\n                innerInstance = instance;\n                hookNotify(getRCNoticeProps(args, prefixCls));\n            });\n        }\n        // Fill functions\n        const hookAPI = {\n            open: notify,\n        };\n        ['success', 'info', 'warning', 'error'].forEach(type => {\n            hookAPI[type] = (args) => hookAPI.open(Object.assign(Object.assign({}, args), { type }));\n        });\n        return [\n            hookAPI,\n            <ConfigConsumer key=\"holder\">\n        {(context) => {\n                ({ getPrefixCls } = context);\n                return holder;\n            }}\n      </ConfigConsumer>,\n        ];\n    };\n    return useNotification;\n}\n"]},"metadata":{},"sourceType":"module"}