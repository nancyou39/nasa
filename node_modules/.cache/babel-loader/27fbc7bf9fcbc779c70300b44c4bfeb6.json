{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsRvh = containsRvh;\nexports.default = void 0;\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction containsRvh(propertyValue) {\n  // TODO: when regexp is lifted up the lexical scope, to be used\n  // in both `containsRvh` and `replaceRvhWithPx`, some tests start to\n  // fail. Seems like a regexp object contains some weird state that\n  // changes after executions; executions interfere with each other.\n  // It would be nice to figure out what is the problem exactly.\n  var rvhRegex = /(\\d+(\\.\\d*)?)rvh(?!\\w)/;\n  return rvhRegex.test(propertyValue);\n}\n\nfunction replaceRvhWithPx(propertyStringValue, windowHeight) {\n  // regexp is global to make #replace work multiple times\n  var rvhRegex = /(\\d+(\\.\\d*)?)rvh(?!\\w)/g;\n  return propertyStringValue.replace(rvhRegex, function (_, rvh) {\n    return \"\".concat(windowHeight * parseFloat(rvh) / 100, \"px\");\n  });\n}\n\nfunction throwOnBadArgs(givenStyle, windowHeight) {\n  if (_typeof(givenStyle) !== 'object' && givenStyle !== undefined || Array.isArray(givenStyle)) throw Error(\"style (the first argument) must be an object or undefined\");\n  if (typeof windowHeight !== 'number' || windowHeight < 0) throw Error('Second argument (windowHeight) must be a non-negative number');\n}\n\nfunction convertStyle(givenStyle, windowHeight) {\n  throwOnBadArgs(givenStyle, windowHeight); // If style is not passed, implicit {height: '100rvh'} style is used.\n\n  var defaultStyle = {\n    height: '100rvh'\n  };\n  var usedStyle = givenStyle === undefined ? defaultStyle : givenStyle;\n  var convertedStyle = {};\n  Object.keys(usedStyle).forEach(function (key) {\n    // if a value contains no rvh unit, it's used as is, otherwise converted\n    // to px; 1rvh = (window.innerHeight / 100)px\n    convertedStyle[key] = typeof usedStyle[key] === 'string' ? replaceRvhWithPx(usedStyle[key], windowHeight) : usedStyle[key];\n  });\n  return convertedStyle;\n}\n\nvar _default = convertStyle;\nexports.default = _default;","map":{"version":3,"sources":["/Users/nancyou/Desktop/nasa/node_modules/react-div-100vh/lib/convertStyle/convertStyle.js"],"names":["Object","defineProperty","exports","value","containsRvh","default","_typeof","obj","Symbol","iterator","constructor","prototype","propertyValue","rvhRegex","test","replaceRvhWithPx","propertyStringValue","windowHeight","replace","_","rvh","concat","parseFloat","throwOnBadArgs","givenStyle","undefined","Array","isArray","Error","convertStyle","defaultStyle","height","usedStyle","convertedStyle","keys","forEach","key","_default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,WAAR,GAAsBA,WAAtB;AACAF,OAAO,CAACG,OAAR,GAAkB,KAAK,CAAvB;;AAEA,SAASC,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,MAAI,OAAOC,MAAP,KAAkB,UAAlB,IAAgC,OAAOA,MAAM,CAACC,QAAd,KAA2B,QAA/D,EAAyE;AAAEH,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAO,OAAOA,GAAd;AAAoB,KAAtD;AAAyD,GAApI,MAA0I;AAAED,IAAAA,OAAO,GAAG,SAASA,OAAT,CAAiBC,GAAjB,EAAsB;AAAE,aAAOA,GAAG,IAAI,OAAOC,MAAP,KAAkB,UAAzB,IAAuCD,GAAG,CAACG,WAAJ,KAAoBF,MAA3D,IAAqED,GAAG,KAAKC,MAAM,CAACG,SAApF,GAAgG,QAAhG,GAA2G,OAAOJ,GAAzH;AAA+H,KAAjK;AAAoK;;AAAC,SAAOD,OAAO,CAACC,GAAD,CAAd;AAAsB;;AAE/V,SAASH,WAAT,CAAqBQ,aAArB,EAAoC;AAClC;AACA;AACA;AACA;AACA;AACA,MAAIC,QAAQ,GAAG,wBAAf;AACA,SAAOA,QAAQ,CAACC,IAAT,CAAcF,aAAd,CAAP;AACD;;AAED,SAASG,gBAAT,CAA0BC,mBAA1B,EAA+CC,YAA/C,EAA6D;AAC3D;AACA,MAAIJ,QAAQ,GAAG,yBAAf;AACA,SAAOG,mBAAmB,CAACE,OAApB,CAA4BL,QAA5B,EAAsC,UAAUM,CAAV,EAAaC,GAAb,EAAkB;AAC7D,WAAO,GAAGC,MAAH,CAAUJ,YAAY,GAAGK,UAAU,CAACF,GAAD,CAAzB,GAAiC,GAA3C,EAAgD,IAAhD,CAAP;AACD,GAFM,CAAP;AAGD;;AAED,SAASG,cAAT,CAAwBC,UAAxB,EAAoCP,YAApC,EAAkD;AAChD,MAAIX,OAAO,CAACkB,UAAD,CAAP,KAAwB,QAAxB,IAAoCA,UAAU,KAAKC,SAAnD,IAAgEC,KAAK,CAACC,OAAN,CAAcH,UAAd,CAApE,EAA+F,MAAMI,KAAK,CAAC,2DAAD,CAAX;AAC/F,MAAI,OAAOX,YAAP,KAAwB,QAAxB,IAAoCA,YAAY,GAAG,CAAvD,EAA0D,MAAMW,KAAK,CAAC,8DAAD,CAAX;AAC3D;;AAED,SAASC,YAAT,CAAsBL,UAAtB,EAAkCP,YAAlC,EAAgD;AAC9CM,EAAAA,cAAc,CAACC,UAAD,EAAaP,YAAb,CAAd,CAD8C,CACJ;;AAE1C,MAAIa,YAAY,GAAG;AACjBC,IAAAA,MAAM,EAAE;AADS,GAAnB;AAGA,MAAIC,SAAS,GAAGR,UAAU,KAAKC,SAAf,GAA2BK,YAA3B,GAA0CN,UAA1D;AACA,MAAIS,cAAc,GAAG,EAArB;AACAjC,EAAAA,MAAM,CAACkC,IAAP,CAAYF,SAAZ,EAAuBG,OAAvB,CAA+B,UAAUC,GAAV,EAAe;AAC5C;AACA;AACAH,IAAAA,cAAc,CAACG,GAAD,CAAd,GAAsB,OAAOJ,SAAS,CAACI,GAAD,CAAhB,KAA0B,QAA1B,GAAqCrB,gBAAgB,CAACiB,SAAS,CAACI,GAAD,CAAV,EAAiBnB,YAAjB,CAArD,GAAsFe,SAAS,CAACI,GAAD,CAArH;AACD,GAJD;AAKA,SAAOH,cAAP;AACD;;AAED,IAAII,QAAQ,GAAGR,YAAf;AACA3B,OAAO,CAACG,OAAR,GAAkBgC,QAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.containsRvh = containsRvh;\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction containsRvh(propertyValue) {\n  // TODO: when regexp is lifted up the lexical scope, to be used\n  // in both `containsRvh` and `replaceRvhWithPx`, some tests start to\n  // fail. Seems like a regexp object contains some weird state that\n  // changes after executions; executions interfere with each other.\n  // It would be nice to figure out what is the problem exactly.\n  var rvhRegex = /(\\d+(\\.\\d*)?)rvh(?!\\w)/;\n  return rvhRegex.test(propertyValue);\n}\n\nfunction replaceRvhWithPx(propertyStringValue, windowHeight) {\n  // regexp is global to make #replace work multiple times\n  var rvhRegex = /(\\d+(\\.\\d*)?)rvh(?!\\w)/g;\n  return propertyStringValue.replace(rvhRegex, function (_, rvh) {\n    return \"\".concat(windowHeight * parseFloat(rvh) / 100, \"px\");\n  });\n}\n\nfunction throwOnBadArgs(givenStyle, windowHeight) {\n  if (_typeof(givenStyle) !== 'object' && givenStyle !== undefined || Array.isArray(givenStyle)) throw Error(\"style (the first argument) must be an object or undefined\");\n  if (typeof windowHeight !== 'number' || windowHeight < 0) throw Error('Second argument (windowHeight) must be a non-negative number');\n}\n\nfunction convertStyle(givenStyle, windowHeight) {\n  throwOnBadArgs(givenStyle, windowHeight); // If style is not passed, implicit {height: '100rvh'} style is used.\n\n  var defaultStyle = {\n    height: '100rvh'\n  };\n  var usedStyle = givenStyle === undefined ? defaultStyle : givenStyle;\n  var convertedStyle = {};\n  Object.keys(usedStyle).forEach(function (key) {\n    // if a value contains no rvh unit, it's used as is, otherwise converted\n    // to px; 1rvh = (window.innerHeight / 100)px\n    convertedStyle[key] = typeof usedStyle[key] === 'string' ? replaceRvhWithPx(usedStyle[key], windowHeight) : usedStyle[key];\n  });\n  return convertedStyle;\n}\n\nvar _default = convertStyle;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}